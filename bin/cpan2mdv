#!/usr/bin/perl
#
#

use strict;
use warnings;

use FindBin qw[ $Bin ];
use lib "$Bin/../lib"; #  if not installed.

use Config::Tiny;
use CPAN2Mdv::Collector;
use CPAN2Mdv::Dist;
use CPAN2Mdv::Downloader;
use CPAN2Mdv::Journal;
use CPAN2Mdv::Resolver;
use CPAN2Mdv::Specifier;
use Getopt::Euclid;
use POE;


# read central configuration.
my $conf = Config::Tiny->read( $ARGV{-config} );
die "Couldn't find a suitable configuration file.\n(Try: $0 --help)\n"
    unless defined $conf;


# create main session.
POE::Session->create(
    inline_states => {
        '_start'          => \&_onpriv_start,
        'rendezvous'      => \&_onpub_rendezvous,
        'resolver_done'   => \&_onpub_resolver_done,
        'collector_done'  => \&_onpub_collector_done,
        'downloader_done' => \&_onpub_downloader_done,
    }
);

POE::Kernel->run();
exit;


#--
# public events

sub _onpub_rendezvous {
    my ($k, $h, $from) = @_[KERNEL, HEAP, ARG0];

    # if rdv with journal, then launch other sessions.
    if ( $from eq 'journal' ) {
        $k->post( 'journal', 'ident', 'main' );
        CPAN2Mdv::Resolver->spawn($conf);
        CPAN2Mdv::Collector->spawn($conf);
        CPAN2Mdv::Downloader->spawn($conf);
        CPAN2Mdv::Specifier->spawn($conf);

        my %waitfor; @waitfor{ qw[ resolver collector downloader specifier ] } = ();
        $h->{waitfor} = \%waitfor;
    }

    # check if we're waiting for other sessions.
    delete $h->{waitfor}{$from};
    my @waitfor   = sort keys %{ $h->{waitfor} };
    my $remaining = scalar @waitfor ? "(remaining: @waitfor)" : '';
    $k->post( 'journal', 'log', "rendezvous with $from $remaining\n" ); # log rdv
    return if scalar @waitfor;

    # process @ARGV
    if ( $ARGV{'<modules>'} ) {
        $k->post( 'journal', 'log', "processing \@ARGV\n" );
        $k->post( 'resolver', 'resolve', CPAN2Mdv::Dist->new({module=>$_}) )
            for @{ $ARGV{'<modules>'} };
    }
}


sub _onpub_resolver_done   { $_[KERNEL]->post( 'collector',  'task', $_[ARG0] ); }
sub _onpub_collector_done  { $_[KERNEL]->post( 'downloader', 'task', $_[ARG0] ); }
sub _onpub_downloader_done { $_[KERNEL]->post( 'specifier',  'task', $_[ARG0] ); }


#--
# private events

sub _onpriv_start {
    my ($k, $session) = @_[KERNEL, SESSION];

    $k->alias_set( 'main' );
    CPAN2Mdv::Journal->spawn;
}


#
# resolve distrib (audio::mpd::collection -> audio-mpd) Resolver
#    v
# resolve to tarball (including version) + metadata  InfoCollecter
#    v
# download tarball   Downloader
#    v
# resolve rpm name + create spec file Specifier
#    v
# build rpm   Builder     > report error, reschedule
#    v
# install rpm Installer   > report error
#    v
# upload rpm to mdv Uploader
#
#
# journal
# cpan rss listener
# cpan walker / mdv
#


__END__

=head1 NAME

cpan2mdv - rpm generator from cpan


=head1 USAGE

    cpan2mdv [-c <file>] [<modules>...]


=head1 VERSION

This documentation refers to cpan2mdv version 0.0.1


=head1 OPTIONS

=over

=item -c[onfig] [=] <file>

Specify alternate configuration file. Defaults in order to
C</etc/cpan2mdv.conf>, or C<../etc/cpan2mdv.conf>.

=for Euclid:
    file.type:      readable
    file.default:   -e '/etc/cpan2mdv.conf' ? '/etc/cpan2mdv.conf' : "$FindBin::Bin/../etc/cpan2mdv.conf"



=item <modules>...

Specify a list of modules to be built.

=for Euclid:
    modules.type: string



=item --version

=item --usage

=item --help

=item --man

Print the usual program information.


=back



=cut


